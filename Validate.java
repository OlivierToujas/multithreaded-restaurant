package cmsc433;

import java.util.HashMap;
import java.util.List;

import cmsc433.SimulationEvent;


/**
 * Validates a simulation
 */
public class Validate {
	// Variables
	public static int numCustomers, numCooks, numTables, machineCapcity;
	public static boolean randomOrders;

	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check, String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/**
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			checkCooksCustomerOrder(events);
			checkCooksFinishedOrder(events);
			checkCooksNumber(events);
			checkCustomerReceivedOrder(events);
			checkCustomersNumber(events);
			checkMachineCapacity(events);
			checkTableLimits(events);

			/* In P2 you will write validation code for things such as:
				Should not have more eaters than specified
				Should not have more cooks than specified
				The Ratsies's capacity should not be exceeded
				The capacity of each machine should not be exceeded
				Eater should not receive order until cook completes it
				Eater should not leave Ratsies's until order is received
				Eater should not place more than one order
				Cook should not work on order before it is placed
			 */

			// Print out the list of events
			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}

	// Get information
	public static void getParameters(int numCustomers, int numCooks, int numTables, int machineCapacity, boolean randomOrders) {
		Validate.numCustomers = numCustomers;
		Validate.numCooks = numCooks;
		Validate.numTables = numTables;
		Validate.machineCapcity = machineCapacity;
		Validate.randomOrders = randomOrders;
	}

	// Individual tests
	// Check number of cooks working and leaving
	private static void checkCooksNumber(List<SimulationEvent> events) throws InvalidSimulationException {
		int cooks = 0;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CookStarting) {
				cooks++;
			}

			if (event.event == SimulationEvent.EventType.CookEnding) {
				cooks--;
			}
		}

		check(cooks == 0, "Cooks number mismatch");
	}

	// Check number of customers entering and leaving
	private static void checkCustomersNumber(List<SimulationEvent> events) throws InvalidSimulationException {
		int customers = 0;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CustomerEnteredRatsies) {
				customers++;
			}

			if (event.event == SimulationEvent.EventType.CustomerLeavingRatsies) {
				customers--;
			}
		}

		check(customers == 0, "Customers number mismatch");
	}

	// Check if the number of customers eating is not more than table size
	private static void checkTableLimits(List<SimulationEvent> events) throws InvalidSimulationException {
		int customers = 0;

		for (SimulationEvent event : events) {
			if (event.event == SimulationEvent.EventType.CustomerEnteredRatsies) {
				customers++;
			}

			if (event.event == SimulationEvent.EventType.CustomerLeavingRatsies) {
				customers--;
			}

			check(customers <= Validate.numTables, "Exceed table limit");
		}
	}

	// Check if machine capacity is over the limit
	private static void checkMachineCapacity(List<SimulationEvent> events) throws InvalidSimulationException {
		int grill = 0, fountain = 0, oven = 0, fryer = 0;

		for (SimulationEvent event : events) {
			if (event.toString().startsWith("Grill")) {
				String[] split = event.toString().split("\\s");

				if (split[1].equals("making")) {
					grill++;
				}else if (split[1].equals("completed")) {
					grill--;
				}
			}

			if (event.toString().startsWith("Fountain")) {
				String[] split = event.toString().split("\\s");

				if (split[1].equals("making")) {
					fountain++;
				}else if (split[1].equals("completed")) {
					fountain--;
				}
			}

			if (event.toString().startsWith("Oven")) {
				String[] split = event.toString().split("\\s");

				if (split[1].equals("making")) {
					oven++;
				}else if (split[1].equals("completed")) {
					oven--;
				}
			}

			if (event.toString().startsWith("Fryer")) {
				String[] split = event.toString().split("\\s");

				if (split[1].equals("making")) {
					fryer++;
				}else if (split[1].equals("completed")) {
					fryer--;
				}
			}

			check(grill <= Validate.machineCapcity, "Grill exceeded machine capacity");
			check(fountain <= Validate.machineCapcity, "Fountain exceeded machine capacity");
			check(oven <= Validate.machineCapcity, "Oven exceeded machine capacity");
			check(fryer <= Validate.machineCapcity, "Fryer exceeded machine capacity");
		}
	}

	// Check if the cooks pick up the order after customers have placed it
	private static void checkCooksCustomerOrder(List<SimulationEvent> events) throws InvalidSimulationException {
		HashMap<Integer, Integer> customerOrder = new HashMap<>();

		for (SimulationEvent event : events) {
			if (event.toString().startsWith("Customer")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("placing")) {
					customerOrder.put(Integer.parseInt(split[1]), Integer.parseInt(split[4]));
				}
			}

			if (event.toString().startsWith("Cook")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("starting")) {
					check(customerOrder.containsValue(Integer.parseInt(split[4])), "Order does not exist");
				}
			}
		}
	}

	// Check if the customers received the order before leaving
	private static void checkCustomerReceivedOrder(List<SimulationEvent> events) throws InvalidSimulationException {
		boolean[] customerOrder = new boolean[Validate.numCustomers];

		for (SimulationEvent event : events) {
			if (event.toString().startsWith("Customer")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("received")) {
					customerOrder[Integer.parseInt(split[1])] = true;
				}
			}

			if (event.toString().startsWith("Customer")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("leaving")) {
					check(customerOrder[Integer.parseInt(split[1])], "Customer leaves without receiving order");
				}
			}
		}
	}

	// Check if the cook finished the order before customers receives it
	private static void checkCooksFinishedOrder(List<SimulationEvent> events) throws InvalidSimulationException {
		boolean[] customerOrder = new boolean[Validate.numCustomers];

		for (SimulationEvent event : events) {
			if (event.toString().startsWith("Cook")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("completed")) {
					customerOrder[Integer.parseInt(split[4]) - 1] = true;
				}
			}

			if (event.toString().startsWith("Customer")) {
				String[] split = event.toString().split("\\s");

				if (split[2].equals("received")) {
					check(customerOrder[Integer.parseInt(split[4]) - 1], "Customer leaves without receiving order");
				}
			}
		}
	}

}
